<?xml version="1.0" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>docs/env.rd</title>
</head>
<body>
<h2><a name="label:0" id="label:0">BDB::Env</a></h2><!-- RDLabel: "BDB::Env" -->
<p>Berkeley DB environment is an encapsulation of one or more databases,
log files and shared information about the database environment such
as shared memory buffer cache pages.</p>
<p>The simplest way to administer a Berkeley DB application environment
is to create a single home directory that stores the files for the
applications that will share the environment. The environment home
directory must be created before any Berkeley DB applications are run.
Berkeley DB itself never creates the environment home directory. The
environment can then be identified by the name of that directory.</p>
<ul>
<li><a href="#label:1">Class Methods</a></li>
<li><a href="#label:28">Methods</a></li>
</ul>
<h3><a name="label:1" id="label:1">Class Methods</a></h3><!-- RDLabel: "Class Methods" -->
<dl>
<dt><a name="label:2" id="label:2"><code>create(<var>home</var> [, <var>flags</var>, <var>mode</var>, <var>options</var>])</code></a><!-- RDLabel: "create" -->
<dt><a name="label:3" id="label:3"><code>new(<var>home</var> [, <var>flags</var>, <var>mode</var>, <var>options</var>])</code></a><!-- RDLabel: "new" -->
<dt><a name="label:4" id="label:4"><code>open(<var>home</var> [, <var>flags</var>, <var>mode</var>, <var>options</var>])</code></a></dt><!-- RDLabel: "open" -->
<dd>
<p>open the Berkeley DB environment</p>
<dl>
<dt><a name="label:5" id="label:5"><var>home</var>
</a></dt><!-- RDLabel: "home
" -->
<dd>
<p>If this argument is non-NULL, its value may be used as the
database home, and files named relative to its path. </p>
</dd>
<dt><a name="label:6" id="label:6"><var>mode</var>
</a></dt><!-- RDLabel: "mode
" -->
<dd>
<p>mode for creation (see chmod(2))</p>
</dd>
<dt><a name="label:7" id="label:7"><var>flags</var>
</a></dt><!-- RDLabel: "flags
" -->
<dd>
<p>must be set to 0 or by OR'ing with  </p>
<dl>
<dt><a name="label:8" id="label:8"><var>BDB::INIT_CDB</var>
</a></dt><!-- RDLabel: "BDB::INIT_CDB
" -->
<dd>
<p>Initialize locking.</p>
</dd>
<dt><a name="label:9" id="label:9"><var>BDB::INIT_LOCK</var>
</a></dt><!-- RDLabel: "BDB::INIT_LOCK
" -->
<dd>
<p>Initialize the locking subsystem.</p>
</dd>
<dt><a name="label:10" id="label:10"><var>BDB::INIT_LOG</var>
</a></dt><!-- RDLabel: "BDB::INIT_LOG
" -->
<dd>
<p>Initialize the logging subsystem.</p>
</dd>
<dt><a name="label:11" id="label:11"><var>BDB::INIT_MPOOL</var>
</a></dt><!-- RDLabel: "BDB::INIT_MPOOL
" -->
<dd>
<p>Initialize the shared memory buffer pool subsystem.</p>
</dd>
<dt><a name="label:12" id="label:12"><var>BDB::INIT_TXN</var>
</a></dt><!-- RDLabel: "BDB::INIT_TXN
" -->
<dd>
<p>Initialize the transaction subsystem.</p>
</dd>
<dt><a name="label:13" id="label:13"><var>BDB::INIT_TRANSACTION</var>
</a></dt><!-- RDLabel: "BDB::INIT_TRANSACTION
" -->
<dd>
<p>Equivalent to 
<var>DB_INIT_LOCK | DB_INIT_MPOOL | DB_INIT_TXN | DB_INIT_LOG</var></p>
</dd>
<dt><a name="label:14" id="label:14"><var>BDB::RECOVER</var>
</a></dt><!-- RDLabel: "BDB::RECOVER
" -->
<dd>
<p>Run normal recovery on this environment before opening it for
normal use. If this flag is set, the DB_CREATE
flag must also be set since the regions will be removed and
recreated.</p>
</dd>
<dt><a name="label:15" id="label:15"><var>BDB::RECOVER_FATAL</var>
</a></dt><!-- RDLabel: "BDB::RECOVER_FATAL
" -->
<dd>
<p>Run catastrophic recovery on this environment before opening
it for normal use. If this flag is set, the DB_CREATE flag
must also be set since the regions will be removed and recreated.</p>
</dd>
<dt><a name="label:16" id="label:16"><var>BDB::USE_ENVIRON</var>
</a></dt><!-- RDLabel: "BDB::USE_ENVIRON
" -->
<dd>
<p>The Berkeley DB process' environment may be permitted to
specify information to be used when naming files</p>
</dd>
<dt><a name="label:17" id="label:17"><var>BDB::USE_ENVIRON_ROOT</var>
</a></dt><!-- RDLabel: "BDB::USE_ENVIRON_ROOT
" -->
<dd>
<p>The Berkeley DB process' environment may be permitted to
specify information to be used when naming files;
if the DB_USE_ENVIRON_ROOT flag is set, environment
information will be used for file naming only for users with
appropriate permissions</p>
</dd>
<dt><a name="label:18" id="label:18"><var>BDB::CREATE</var>
</a></dt><!-- RDLabel: "BDB::CREATE
" -->
<dd>
<p>Cause Berkeley DB subsystems to create any underlying
files, as necessary.</p>
</dd>
<dt><a name="label:19" id="label:19"><var>BDB::LOCKDOWN</var>
</a></dt><!-- RDLabel: "BDB::LOCKDOWN
" -->
<dd>
<p>Lock shared Berkeley DB environment files and memory mapped
databases into memory.</p>
</dd>
<dt><a name="label:20" id="label:20"><var>BDB::NOMMAP</var>
</a></dt><!-- RDLabel: "BDB::NOMMAP
" -->
<dd>
<p>Always copy read-only database files in this environment
into the local cache instead of potentially mapping
them into process memory </p>
</dd>
<dt><a name="label:21" id="label:21"><var>BDB::PRIVATE</var>
</a></dt><!-- RDLabel: "BDB::PRIVATE
" -->
<dd>
<p>Specify that the environment will only be accessed by a
single process</p>
</dd>
<dt><a name="label:22" id="label:22"><var>BDB::SYSTEM_MEM</var>
</a></dt><!-- RDLabel: "BDB::SYSTEM_MEM
" -->
<dd>
<p>Allocate memory from system shared memory instead of from
memory backed by the filesystem.</p>
</dd>
<dt><a name="label:23" id="label:23"><var>BDB::TXN_NOSYNC</var>
</a></dt><!-- RDLabel: "BDB::TXN_NOSYNC
" -->
<dd>
<p>Do not synchronously flush the log on transaction commit or
prepare. This means that transactions exhibit the
ACI (atomicity, consistency and isolation) properties, but not
D (durability), i.e., database integrity will
be maintained but it is possible that some number of the
most recently committed transactions may be undone
during recovery instead of being redone. </p>
</dd>
<dt><a name="label:24" id="label:24"><var>BDB::CDB_ALLDB</var>
</a></dt><!-- RDLabel: "BDB::CDB_ALLDB
" -->
<dd>
<p>For Berkeley DB Concurrent Data Store applications, perform
locking on an environment-wide basis rather than per-database.</p>
</dd>
</dl>
</dd>
<dt><a name="label:25" id="label:25"><var>options</var>
</a></dt><!-- RDLabel: "options
" -->
<dd>
<p>hash. See the documentation of Berkeley DB for possible values.</p>
</dd>
</dl></dd>
<dt><a name="label:26" id="label:26"><code>remove()</code></a><!-- RDLabel: "remove" -->
<dt><a name="label:27" id="label:27"><code>unlink()</code></a></dt><!-- RDLabel: "unlink" -->
<dd>
<p>remove the environnement</p></dd>
</dl>
<h3><a name="label:28" id="label:28">Methods</a></h3><!-- RDLabel: "Methods" -->
<dl>
<dt><a name="label:29" id="label:29"><code>close()</code></a></dt><!-- RDLabel: "close" -->
<dd>
<p>close the environnement</p></dd>
<dt><a name="label:30" id="label:30"><code>lock()</code></a><!-- RDLabel: "lock" -->
<dt><a name="label:31" id="label:31"><code>lock_id()</code></a></dt><!-- RDLabel: "lock_id" -->
<dd>
<p>Acquire a locker ID</p></dd>
<dt><a name="label:32" id="label:32"><code>lock_detect(<var>type</var> [, <var>flags</var>])</code></a></dt><!-- RDLabel: "lock_detect" -->
<dd>
<p>The lock_detect function runs one iteration of the deadlock
detector. The deadlock detector traverses the lock table, and for each
deadlock it finds, marks one of the participating transactions for
abort.</p>
<p><var>type</var> can have one the value <var>BDB::LOCK_OLDEST</var>,
<var>BDB::LOCK_RANDOM</var> or <var>BDB::LOCK_YOUNGUEST</var></p>
<p><var>flags</var> can have the value <var>BDB::LOCK_CONFLICT</var>, in this case
the deadlock detector is run only if a lock conflict has occurred
since the last time that the deadlock detector was run.   </p>
<p>return the number of transactions aborted by the lock_detect function
if <var>BDB::VERSION_MAJOR &gt;= 3</var> or <var>zero</var></p></dd>
<dt><a name="label:33" id="label:33"><code>lock_stat()</code></a></dt><!-- RDLabel: "lock_stat" -->
<dd>
<p>Return lock subsystem statistics</p></dd>
<dt><a name="label:34" id="label:34"><code>log_archive([<var>flags</var>])</code></a></dt><!-- RDLabel: "log_archive" -->
<dd>
<p>The log_archive function return an array of log or database file names.</p>
<p><var>flags</var> value must be set to 0 or the value <var>BDB::ARCH_DATA</var>,
<var>BDB::ARCH_ABS</var>, <var>BDB::ARCH_LOG</var></p></dd>
<dt><a name="label:35" id="label:35"><code>log_checkpoint(<var>string</var>)</code></a></dt><!-- RDLabel: "log_checkpoint" -->
<dd>
<p>same as <var>log_put(string, BDB::CHECKPOINT)</var></p></dd>
<dt><a name="label:36" id="label:36"><code>log_curlsn(<var>string</var>)</code></a></dt><!-- RDLabel: "log_curlsn" -->
<dd>
<p>same as <var>log_put(string, BDB::CURLSN)</var></p></dd>
<dt><a name="label:37" id="label:37"><code>log_each { |<var>string</var>, <var>lsn</var>| ... }</code></a></dt><!-- RDLabel: "log_each" -->
<dd>
<p>Implement an iterator inside of the log</p></dd>
<dt><a name="label:38" id="label:38"><code>log_flush([<var>string</var>])</code></a></dt><!-- RDLabel: "log_flush" -->
<dd>
<p>same as <var>log_put(string, BDB::FLUSH)</var></p>
<p>Without argument, garantee that all records are written to the disk</p></dd>
<dt><a name="label:39" id="label:39"><code>log_get(<var>flag</var>)</code></a></dt><!-- RDLabel: "log_get" -->
<dd>
<p>The <var>log_get</var> return an array <var>[String, BDB::Lsn]</var> according to
the <var>flag</var> value.</p>
<p><var>flag</var> can has the value <var>BDB::CHECKPOINT</var>, <var>BDB::FIRST</var>, 
<var>BDB::LAST</var>, <var>BDB::NEXT</var>, <var>BDB::PREV</var>, <var>BDB::CURRENT</var></p></dd>
<dt><a name="label:40" id="label:40"><code>log_put(<var>string</var> [, <var>flag</var>])</code></a></dt><!-- RDLabel: "log_put" -->
<dd>
<p>The <var>log_put</var> function appends records to the log. It return
an object <var>BDB::Lsn</var></p>
<p><var>flag</var> can have the value <var>BDB::CHECKPOINT</var>, <var>BDB::CURLSN</var>,
<var>BDB::FLUSH</var></p></dd>
<dt><a name="label:41" id="label:41"><code>log_reverse_each { |<var>string</var>, <var>lsn</var>| ... }</code></a></dt><!-- RDLabel: "log_reverse_each" -->
<dd>
<p>Implement an iterator inside of the log</p></dd>
<dt><a name="label:42" id="label:42"><code>log_stat</code></a></dt><!-- RDLabel: "log_stat" -->
<dd>
<p>return log statistics</p></dd>
<dt><a name="label:43" id="label:43"><code>open_db(<var>type</var> [, <var>name</var>, <var>subname</var>, <var>flags</var>, <var>mode</var>])</code></a></dt><!-- RDLabel: "open_db" -->
<dd>
<p>open the database in the current environment. type must be one of
the constant <var>BDB::BTREE</var>, <var>BDB::HASH</var>, <var>BDB::RECNO</var>, 
<var>BDB::QUEUE</var>. See <a href="access.html#open">open</a> for other
arguments</p></dd>
<dt><a name="label:44" id="label:44"><code>recover { |<var>txn</var>, <var>id</var>| ... }</code></a></dt><!-- RDLabel: "recover" -->
<dd>
<p>only with BDB::VERSION_MAJOR == 3 &amp;&amp; BDB::VERSION_MINOR &gt;= 3</p>
<p>iterate over all prepared transactions. The transaction <var>txn</var>
must be made a call to #abort, #commit, #discard</p>
<p><var>id</var> is the global transaction ID for the transaction</p></dd>
<dt><a name="label:45" id="label:45"><code>set_flags(<var>flags</var> [, <var>onoff</var>])</code></a></dt><!-- RDLabel: "set_flags" -->
<dd>
<p>only with BDB::VERSION_MAJOR == 3 &amp;&amp; BDB::VERSION_MINOR &gt;= 2</p>
<p><var>flags</var> can have the value <var>BDB::CDB_ALLDB</var>, <var>BDB::NOMMAP</var>
<var>BDB::TXN_NOSYNC</var></p>
<p>if <var>onoff</var> is zero, the specified flags are cleared</p></dd>
<dt><a name="label:46" id="label:46"><code>txn_begin([<var>flags</var>])</code></a><!-- RDLabel: "txn_begin" -->
<dt><a name="label:47" id="label:47"><code>begin([<var>flags</var>])</code></a><!-- RDLabel: "begin" -->
<dt><a name="label:48" id="label:48"><code>begin([<var>flags</var>, <var>db</var>, ...]) { |<var>txn</var>, <var>db</var>, ...| ...}</code></a></dt><!-- RDLabel: "begin" -->
<dd>
<p>begin a transaction (the transaction manager must be enabled). flags
can have the value <var>DBD::TXN_COMMIT</var>, in this case the transaction
will be commited at end.</p></dd>
<dt><a name="label:49" id="label:49"><code>txn_checkpoint(<var>kbyte</var> [, <var>min</var>])</code></a><!-- RDLabel: "txn_checkpoint" -->
<dt><a name="label:50" id="label:50"><code>checkpoint(<var>kbyte</var> [, <var>min</var>])</code></a></dt><!-- RDLabel: "checkpoint" -->
<dd>
<p>The txn_checkpoint function flushes the underlying memory pool,
writes a checkpoint record to the log and then flushes the log.</p>
<p>If either kbyte or min is non-zero, the checkpoint is only done
if more than min minutes have passed since the last checkpoint, or if
more than kbyte kilobytes of log data have been written since the last
checkpoint.</p></dd>
<dt><a name="label:51" id="label:51"><code>txn_stat()</code></a><!-- RDLabel: "txn_stat" -->
<dt><a name="label:52" id="label:52"><code>stat()</code></a></dt><!-- RDLabel: "stat" -->
<dd>
<p>Return transaction subsystem statistics</p></dd>
</dl>
<h3><a name="label:53" id="label:53">Only for DB &gt;= 4</a></h3><!-- RDLabel: "Only for DB >= 4" -->
<dl>
<dt><a name="label:54" id="label:54"><code>rep_elect(<var>sites</var>, <var>priority</var>, <var>timeout</var>)</code></a><!-- RDLabel: "rep_elect" -->
<dt><a name="label:55" id="label:55"><code>elect(<var>sites</var>, <var>priority</var>, <var>timeout</var>)</code></a></dt><!-- RDLabel: "elect" -->
<dd>
<p>Holds an election for the master of a replication group, returning the
new master's ID</p>
<p>Raise <var>BDB::RepUnavail</var> if the <var>timeout</var> expires</p></dd>
<dt><a name="label:56" id="label:56"><code>rep_process_message(<var>control</var>, <var>rec</var>, <var>envid</var>)</code></a><!-- RDLabel: "rep_process_message" -->
<dt><a name="label:57" id="label:57"><code>process_message(<var>control</var>, <var>rec</var>, <var>envid</var>)</code></a></dt><!-- RDLabel: "process_message" -->
<dd>
<p>Processes an incoming replication message sent by a member of the
replication group to the local database environment</p></dd>
<dt><a name="label:58" id="label:58"><code>rep_start(<var>cdata</var>, <var>flags</var>)</code></a><!-- RDLabel: "rep_start" -->
<dt><a name="label:59" id="label:59"><code>start(<var>cdata</var>, <var>flags</var>)</code></a></dt><!-- RDLabel: "start" -->
<dd>
<p><var>cdata</var> is an identifier
<var>flags</var> must be one of <var>BDB::REP_CLIENT</var>, <var>BDB::REP_MASTER</var>
or <var>BDB::REP_LOGSONLY</var></p></dd>
</dl>

</body>
</html>
